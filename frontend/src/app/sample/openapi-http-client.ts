/**
 * Abstraction over HTTPClient to create type-safe data fetching based on the
 * types generated by OpenAPI.
 *
 * The usage follows a similar pattern to `openapi-fetch`.
 */

import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { lastValueFrom, Observable } from 'rxjs';
import { paths } from '../schema';
import { injectQuery } from '@tanstack/angular-query-experimental';

type HttpMethod =
  | 'get'
  | 'put'
  | 'post'
  | 'delete'
  | 'options'
  | 'head'
  | 'patch'
  | 'trace';

type PathsWithMethod<Paths extends {}, PathnameMethod extends HttpMethod> = {
  [Pathname in keyof Paths]: Paths[Pathname] extends {
    [K in PathnameMethod]: any;
  }
    ? Pathname
    : never;
}[keyof Paths];

// Extract operation type for a given method and path
type OperationForMethod<
  Method extends HttpMethod,
  Path extends keyof paths
> = paths[Path] extends { [K in Method]: infer Op } ? Op : never;

// Extract path parameters type from an operation
type PathParams<Op> = Op extends { parameters: { path: infer P } } ? P : never;

// Extract query parameters type from an operation
type QueryParams<Op> = Op extends { parameters: { query: infer Q } }
  ? Q
  : never;

// Extract request body type from an operation
type RequestBody<Op> = Op extends {
  requestBody: { content: { 'application/json': infer B } };
}
  ? B
  : never;

// Extract response type (200 response) from an operation
type ApiResponseType<Op> = Op extends {
  responses: {
    200: { content: { 'application/json': infer R } };
  };
}
  ? R
  : never;

/**
 * Sample abstraction over HTTPClient that uses types generated by OpenAPI
 */
@Injectable({
  providedIn: 'root'
})
export class OpenApiHHTPClient {
  // Inject Angular's HTTP client
  private http = inject(HttpClient);

  private query<
    Method extends HttpMethod,
    Path extends PathsWithMethod<paths, Method>,
    Op = OperationForMethod<Method, Path>,
    PathParamsType = PathParams<Op>,
    QueryParamsType = QueryParams<Op>,
    RequestBodyType = RequestBody<Op>,
    ResponseType = ApiResponseType<Op>
  >(
    method: Method,
    path: Path,
    options: {
      pathParams?: PathParamsType extends never ? never : PathParamsType;
      queryParams?: QueryParamsType extends never ? never : QueryParamsType;
      body?: RequestBodyType extends never ? never : RequestBodyType;
    } = {}
  ): Observable<ResponseType> {
    // Replace path parameters in the URL
    let url = path as string;
    if (options.pathParams) {
      Object.entries(options.pathParams).forEach(([key, value]) => {
        url = url.replace(`{${key}}`, String(value));
      });
    }

    // Build query parameters
    let params = new HttpParams();
    if (options.queryParams) {
      Object.entries(options.queryParams).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          params = params.set(key, String(value));
        }
      });
    }

    // Make the HTTP request based on method
    switch (method) {
      case 'get':
        return this.http.get<ResponseType>(url, { params });
      case 'post':
        return this.http.post<ResponseType>(url, options.body, { params });
      case 'put':
        return this.http.put<ResponseType>(url, options.body, { params });
      case 'delete':
        return this.http.delete<ResponseType>(url, { params });
      case 'patch':
        return this.http.patch<ResponseType>(url, options.body, { params });
      case 'head':
        return this.http.head<ResponseType>(url, { params });
      case 'options':
        return this.http.options<ResponseType>(url, { params });
      default:
        throw new Error(`Unsupported HTTP method: ${method}`);
    }
  }

  // Convenience methods for common HTTP methods
  get<Path extends PathsWithMethod<paths, 'get'>>(
    path: Path,
    options?: {
      pathParams?: PathParams<OperationForMethod<'get', Path>>;
      queryParams?: QueryParams<OperationForMethod<'get', Path>>;
    }
  ) {
    return lastValueFrom(this.query('get', path, options as any));
  }

  queryGet<Path extends PathsWithMethod<paths, 'get'>>(
    path: Path,
    options?: {
      pathParams?: PathParams<OperationForMethod<'get', Path>>;
      queryParams?: QueryParams<OperationForMethod<'get', Path>>;
    }
  ) {
    return injectQuery(() => ({
      queryKey: ['get', path],
      queryFn: () => lastValueFrom(this.query('get', path, options as any))
    }));
  }

  post<Path extends PathsWithMethod<paths, 'post'>>(
    path: Path,
    options?: {
      pathParams?: PathParams<OperationForMethod<'post', Path>>;
      queryParams?: QueryParams<OperationForMethod<'post', Path>>;
      body?: RequestBody<OperationForMethod<'post', Path>>;
    }
  ) {
    return lastValueFrom(this.query('post', path, options as any));
  }

  put<Path extends PathsWithMethod<paths, 'put'>>(
    path: Path,
    options?: {
      pathParams?: PathParams<OperationForMethod<'put', Path>>;
      queryParams?: QueryParams<OperationForMethod<'put', Path>>;
      body?: RequestBody<OperationForMethod<'put', Path>>;
    }
  ) {
    return lastValueFrom(this.query('put', path, options as any));
  }

  delete<Path extends PathsWithMethod<paths, 'delete'>>(
    path: Path,
    options?: {
      pathParams?: PathParams<OperationForMethod<'delete', Path>>;
      queryParams?: QueryParams<OperationForMethod<'delete', Path>>;
    }
  ) {
    return lastValueFrom(this.query('delete', path, options as any));
  }
}
